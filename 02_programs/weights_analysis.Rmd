---
title: "Weights Analysis"
author: "Brian Stacy"
date: "2/5/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.width = 9, fig.height = 6, fig.cap = "&nbsp;", fig.path = "plots/", dev = c("png"), dpi=500)
library(tidyverse)
library(flextable)
library(here)
# devtools::install_github("worldbank/wbgviz", subdir = "wbgcharts")
# devtools::install_github("worldbank/wbgviz", subdir = "wbggeo")
# devtools::install_github("worldbank/wbgviz", subdir = "wbgmaps")
# library(wbggeo)
# library(wbgmaps)
library(ggthemes)
library(Hmisc)
library(httr)
library(patchwork)
library(ggrepel)
library(haven)
library(zoo)
library(estimatr)
library(ggpmisc)
library(ggthemes)
library(ggtext)
library(ggridges)
library(kableExtra)
library(skimr)

#set directories
dir <- here()

raw_dir <- paste(dir, '01_raw_data', sep="/")
output_dir <- paste(dir, '03_output_data', sep="/")

#weights (either unity (1) or population (2))
wgt <- 1

# number of trials
trials <- 500

```


```{r themes}

#ggplot theme
theme_spi <- function () { 
    theme_bw() %+replace%
    theme(
      #plot.title=element_blank() remove all titles from plots (sometimes we may need to bring title outside plot)
    )
}

```


# Motivation

This program will help us to understand the consequences of weights in our SPI scores.  We will randomly choose weights for `r trials` trials.  Weights will be constrained to sum to 1, and will be randomly drawn for each pillar and dimension to sum to 1.

```{r data, include=FALSE}

#add in population
pop_df <- wbstats::wb(country="all",
             indicator='SP.POP.TOTL',
             startdate=2004,
             enddate=2019) %>%
  mutate(date=as.numeric(date)) %>%
  mutate(population=value) %>%
  select(country, date, population) 


#read in the SPI dataset
spi_df_final <- read_csv( file = paste(output_dir, 'SPI_data.csv', sep="/")) %>%
  left_join(pop_df) %>%
  mutate(wgt=wgt,
         weights=if_else(wgt==2,population,1))  #create a variable for weights for estimates.  This just makes is easier to switch between weights and unweighted estimates.



metadata <- read_csv(paste(raw_dir, '/metadata/SPI_dimensions_sources.csv', sep=""))

metadata_full <- read_csv(paste(raw_dir, '/metadata/SPI_index_sources.csv', sep="")) %>%
  rename(source_name=descript) %>%
  bind_rows(metadata)
                             

pillars <- read_csv(paste(raw_dir, '/metadata/SPI_pillars.csv', sep=""))


#import data
SPI <- read_csv(paste(output_dir, 'SPI_index.csv', sep="/")) %>%
#     left_join(pop_df) %>%
   mutate(weights=wgt)  #create a variable for weights for estimates.  This just makes is easier to switch between weights and unweighted estimates.

SPI_2019 <- SPI %>%
  filter(date==2019) %>%
  mutate(trial='original') %>%
  select(trial, country, date, SPI.INDEX, region, income) %>%
  arrange(-SPI.INDEX)

country_order <- SPI_2019$country

```


# SPI Index Methodology 

We next produce an overall score by combining the indicators we have collected.  Our statistical performance indicators have a three level structure, and our SPI overall score will be formed by sequentially aggregating each level.

To begin we produce a score for each pillar, which is an unweighted average of the indicators within that pillar.  For instance, the Census and Surveys pillar will be formed by taking the unweighted average of the Population Census score, the Agriculture Census score, the Business Census score, the Labor Force Survey score, the Health Survey score, etc.  

$$ SPI.PILLAR_{ctds} = \sum_{i=1}^{N_I} \frac{SPI.IND_{ctdsi}}{N_I} $$

where $SPI.PILLAR_{ctds}$ is pillar s, in dimension d, in time period t, and country c.  $SPI.IND_{ctdsi}$ is an indicator (e.g. population census score).

After computing a score for the pillar, we then compute a dimension score, which is the average of the pillars in that dimension. For dimensions 1, 2, 4, and 5, we take the unweighted average of the pillars in the dimension.  However, for Dimension 3 on data products, we take a weighted average of the pillars, where the weights are based on the number of SDGs in each pillar (6 SDGs in Pillar 3.1 on social statistics, 6 SDGs in Pillar 3.2 on economic statistics, 2 in Pillar 3.3 on environmental statistics, and 2 in Pillar 3.4 on institutional statistics).  We take the perspective that all SDGs are of equal importance, and therefore weight our pillars accordingly.  Additionally, for Dimension 4 on data sources, we give censuses and surveys separate weights, so that censuses get 1/4th weight, surveys get 1/4th weight, admin data gets 1/4th weight, and geospatial gets 1/4th weight.  While censuses and surveys are in the same pillar in our framework, and therefore would typically only receive 1/3 weight in this dimension, because of their importance in producing many indicators, they are given extra weight with a sum of 1/2.

$$ SPI.DIM_{ctd} = \sum_{s=1}^{N_S} \frac{\omega_{ds} \times SPI.PILLAR_{ctds}}{N_S} $$

$\omega_{ds}$ is the weight for pillar s in dimension d.

After calculating the scores for each dimension, the SPI overall score is the average across the 5 dimensions. 

The SPI overall score is scaled to have a maximum score of 100 and a minimum of 0. A score of 100 would indicate that a country has every single element that we measure in place. A score of 0 indicates that none are in place. To be precise:



$$ SPI.INDEX_{ct} = \sum_{d=1}^{N_D} \frac{SPI.DIM_{ctd}}{N_D} $$

Where SPI.INDEX is the SPI overall score. SPI.DIM are the 5 SPI dimensions listed above. In the notation, c is a country, t is the date, d is a dimension.  

The nested structure of our index and the summation methods used to build an overall score ensure the axiomatic properties outlined in [@cameron2019measuring].  These include symmetry, monotonicity, and subgroup decomposability.


# SPI Overall Scores


```{r spi_df}

# This block of code will create a blank SPI dataset (only containing country info) that will be appended to when each indicator is added.
# There will be two indicators added for each dimension
# 1. An indicator with a score between 0-1 for each dimension
# 2. An indicator with the raw (unscored) values of the indicators
# The unit for this database will be country*year

span <- c(2004:2019)

spi_df_empty <- bind_rows(replicate(length(span), wbstats::wbcountries(), simplify = FALSE), .id='date') %>%
  mutate(date=as.numeric(date)+span[1]-1) %>%
  filter(region!="Aggregates") # take out the aggregates (LAC, SAR, etc)

spi_df <- spi_df_empty

#read list of iso3c codes for matching from UN (https://unstats.un.org/unsd/methodology/m49/)
iso3c <- read_csv(paste(raw_dir,'metadata/iso_codes.csv', sep="/"),
                  col_types=list(col_character(), col_character(), col_character()))

```


  

```{r trial_fun}

trial_fun <- function(trial_num) {
  

  #set seed
  set.seed(trial_num)
  
  # create index dataset
  spi_index_df_temp <- spi_df_final %>%
    select(country, iso3c, date, starts_with("SPI"), income, region, weights, population) %>%
    arrange(-date,country)
  
  #Drop certain indicators that don't make cut because of imcomplete coverage usually
  spi_index_df_temp <- spi_index_df_temp %>%
    select( -SPI.D5.3.DISK, -SPI.D4.3.GEO.second.admin.level) 
  
  
  #weights
  #Dimension 1 - Overall Weight
  dim_1 <- runif(1)
  #Pillar 1.5: Data Use by International Organizations
  pillar_1_5 <- 1
  
  #Dimension 2 - Overall Weight
  dim_2 <- runif(1)
  #Pillar 2.1: Data releases
  pillar_2_1 <- runif(1)
  #Pillar 2.2: Online access
  pillar_2_2 <- runif(1)
  # Pillar 2.4: Data services
  pillar_2_4 <- runif(1)
  
  # Dimension 3 - Overall Weight
  dim_3 <- runif(1)
  # Pillar 3: SDG 1
  pillar_3_1 <- runif(1)
  # Pillar 3: SDG 2
  pillar_3_2 <- runif(1)
  # Pillar 3: SDG 3
  pillar_3_3 <- runif(1)
  # Pillar 3: SDG 4
  pillar_3_4 <- runif(1)
  # Pillar 3: SDG 5
  pillar_3_5 <- runif(1)
  # Pillar 3: SDG 6
  pillar_3_6 <- runif(1)
  # Pillar 3: SDG 7
  pillar_3_7 <- runif(1)
  # Pillar 3: SDG 8
  pillar_3_8 <- runif(1)
  # Pillar 3: SDG 9
  pillar_3_9 <- runif(1)
  # Pillar 3: SDG 10
  pillar_3_10 <- runif(1)
  # Pillar 3: SDG 11
  pillar_3_11 <- runif(1)
  # Pillar 3: SDG 12
  pillar_3_12 <- runif(1)
  # Pillar 3: SDG 13
  pillar_3_13 <- runif(1)
  # Pillar 3: SDG 15
  pillar_3_15 <- runif(1)
  # Pillar 3: SDG 16
  pillar_3_16 <- runif(1)
  # Pillar 3: SDG 17
  pillar_3_17 <- runif(1)
  
  #Dimension 4 - Overall Weight
  dim_4 <- runif(1)
  # Pillar 4.1: censuses and surveys
  pillar_4_1.CEN <- runif(1)
  pillar_4_1.SVY <- runif(1)
  #Pillar 4.2: administrative data
  pillar_4_2 <- runif(1)
  # Pillar 4.3: geospatial data
  pillar_4_3 <- runif(1)
  
  # Dimension 5 - Overall Weight
  dim_5 <- runif(1)
  # Pillar 5.2: Standards and Methods
  pillar_5_2 <- 1
  
  
  #################
  # Nested Index
  ################
  spi_index_df <- spi_index_df_temp %>%
    arrange(country, date) %>%
    group_by(country) %>%
    mutate(across(starts_with("SPI"), na.locf, na.rm=FALSE)) %>%
    select(country, iso3c, date, everything())
  
  
  
  #recalculate index based on the weights
  dim_total <- dim_1 + dim_2 + dim_3 + dim_4 + dim_5
  dim2_total <- pillar_2_1 + pillar_2_2 + pillar_2_4
  dim3_total <- 
    pillar_3_1 + 
    pillar_3_2 +
    pillar_3_3 +
    pillar_3_4 +
    pillar_3_5 +
    pillar_3_6 +
    pillar_3_7 +
    pillar_3_8 +
    pillar_3_9 +
    pillar_3_10 +
    pillar_3_11 +
    pillar_3_12 +
    pillar_3_13 +
    pillar_3_15 +
    pillar_3_16 +
    pillar_3_17
  dim4_total <- pillar_4_1.CEN + pillar_4_1.SVY + + pillar_4_2 + pillar_4_3
  
  #create index dataset
  spi_index_df <- spi_index_df %>%
    mutate(INDEX.SPI.D2.1=rowMeans(across(starts_with('SPI.D2.1'))),
           INDEX.SPI.D2.2=SPI.D2.2.Openness.subscore,
           INDEX.SPI.D2.4=SPI.D2.4.NADA,
           INDEX.SPI.D3.1=rowMeans(across(c("SPI.D3.1.POV",
                                            "SPI.D3.2.HNGR",
                                            "SPI.D3.3.HLTH",
                                            "SPI.D3.4.EDUC",
                                            "SPI.D3.5.GEND",
                                            "SPI.D3.6.WTRS"))),
           INDEX.SPI.D3.2=rowMeans(across(c("SPI.D3.7.ENRG",
                                            "SPI.D3.8.WORK",
                                            "SPI.D3.9.INDY",
                                            "SPI.D3.10.NEQL",
                                            "SPI.D3.11.CITY",
                                            "SPI.D3.12.CNSP"))),         
           INDEX.SPI.D3.3=rowMeans(across(c("SPI.D3.13.CLMT",
                                            "SPI.D3.15.LAND" ))),
           INDEX.SPI.D3.4=rowMeans(across(c("SPI.D3.16.INST",
                                            "SPI.D3.17.PTNS" ))),
           INDEX.SPI.D4.1.CEN=rowMeans(across(c('SPI.D4.1.1.POPU','SPI.D4.1.2.AGRI','SPI.D4.1.3.BIZZ'))), #separate census and surveys 
           INDEX.SPI.D4.1.SVY=rowMeans(across(c('SPI.D4.1.4.HOUS','SPI.D4.1.5.AGSVY','SPI.D4.1.6.LABR', 'SPI.D4.1.7.HLTH','SPI.D4.1.8.BZSVY'))), #separate census and surveys 
           INDEX.SPI.D4.2=rowMeans(across(starts_with('SPI.D4.2'))),
           INDEX.SPI.D4.3=rowMeans(across(starts_with('SPI.D4.3'))),
           #INDEX.SPI.D5.1=rowMeans(across(starts_with('SPI.D5.1'))),
           INDEX.SPI.D5.2=rowMeans(across(starts_with('SPI.D5.2'))),
           #INDEX.SPI.D5.5=rowMeans(across(starts_with('SPI.D5.5')))
    ) %>%
    mutate(
      SPI.INDEX.DIM1=rowMeans(across(starts_with("SPI.D1.5")), na.rm=FALSE),
      SPI.INDEX.DIM2=(
        (pillar_2_1/dim2_total)*INDEX.SPI.D2.1 +
          (pillar_2_2/dim2_total)*INDEX.SPI.D2.2 +
          (pillar_2_4/dim2_total)*INDEX.SPI.D2.4 )
      ,
      SPI.INDEX.DIM3=(
        (pillar_3_1/dim3_total)*SPI.D3.1.POV +
          (pillar_3_2/dim3_total)*SPI.D3.2.HNGR +
          (pillar_3_3/dim3_total)*SPI.D3.3.HLTH +
          (pillar_3_4/dim3_total)*SPI.D3.4.EDUC +
          (pillar_3_5/dim3_total)*SPI.D3.5.GEND +
          (pillar_3_6/dim3_total)*SPI.D3.6.WTRS +
          (pillar_3_7/dim3_total)*SPI.D3.7.ENRG +
          (pillar_3_8/dim3_total)*SPI.D3.8.WORK +
          (pillar_3_9/dim3_total)*SPI.D3.9.INDY +
          (pillar_3_10/dim3_total)*SPI.D3.10.NEQL +
          (pillar_3_11/dim3_total)*SPI.D3.11.CITY +
          (pillar_3_12/dim3_total)*SPI.D3.12.CNSP +
          (pillar_3_13/dim3_total)*SPI.D3.13.CLMT +
          (pillar_3_15/dim3_total)*SPI.D3.15.LAND +
          (pillar_3_16/dim3_total)*SPI.D3.16.INST +
          (pillar_3_17/dim3_total)*SPI.D3.17.PTNS)
      ,
      SPI.INDEX.DIM4=(
        (pillar_4_1.CEN/dim4_total)*INDEX.SPI.D4.1.CEN +
          (pillar_4_1.SVY/dim4_total)*INDEX.SPI.D4.1.SVY +
          (pillar_4_2/dim4_total)*INDEX.SPI.D4.2 +
          (pillar_4_3/dim4_total)*INDEX.SPI.D4.3 )
      ,
      SPI.INDEX.DIM5=rowMeans(across(starts_with("INDEX.SPI.D5")), na.rm=FALSE),
      SPI.INDEX=(dim_1/dim_total)*SPI.INDEX.DIM1 +
        (dim_2/dim_total)*SPI.INDEX.DIM2 +
        (dim_3/dim_total)*SPI.INDEX.DIM3 +
        (dim_4/dim_total)*SPI.INDEX.DIM4 +
        (dim_5/dim_total)*SPI.INDEX.DIM5 
      #sum up based on individual dimension weights
    ) %>% #
    mutate(across(starts_with('SPI.INDEX'),~100*.)) %>%
    arrange(-date, -SPI.INDEX) %>%
    select(country, iso3c, date, starts_with('SPI.INDEX'), everything()) 
  #  filter(date>=2016) #2016 is first year with complete data
  
  
  spi_index_df %>%
    filter(date==2019) %>%
    select(country, date, SPI.INDEX, region, income)

}


```


```{r trials}
#initial df
trial_df <- data.frame(trial=c(1:trials))

#launch trials using map
trial_df <- trial_df %>%
  mutate(try=trial) %>%
  nest(try) %>%
  mutate(
    trial_data=map(
      data,
      ~trial_fun(as.numeric(.x$try))
    )
  ) %>%
  unnest(trial_data)


```

## Ridge Plot    

Below shows the distribution of estimates for each country across the `r trials` trials. 


```{r ridgeplot_jack, echo=FALSE, fig.height=22, fig.width=10}


trial_df <- trial_df %>%
  mutate(country=factor(country,levels=country_order)) %>%
  filter(!is.na(SPI.INDEX))

plot_ridge <- ggplot(data=trial_df, aes(x=SPI.INDEX, y=country)) +
  facet_wrap(~region, scales='free_y') +
  geom_density_ridges(fill='#2a9d8f') +
  labs(x='SPI Overall Score') +
  theme_bw() +
  ggtitle('Distribution of SPI Overall Scores Assigning Random Weights to Pillars and Dimensions') 

plot_ridge
```

```{r table}

table <- trial_df %>%
  select(country, SPI.INDEX) %>%
  group_by(country) %>%
  skim() %>%
  left_join(SPI_2019) %>%
  select(country, SPI.INDEX, numeric.mean, numeric.sd, numeric.p0, numeric.p25, numeric.p50, numeric.p75, numeric.p100, numeric.hist)

kable(table,
      digits=1,
      col.names = c("Country", "Actual SPI Overall Score", "Mean", "Std Dev", "Min", "P25","Median","P75", "Max", "Histogram"),
      caption = "Results from Random Trials where weights are randomly assigned.") %>%
  kable_styling()
  

```

